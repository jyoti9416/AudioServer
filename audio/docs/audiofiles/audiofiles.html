<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>audiofiles.audiofiles API documentation</title>
<meta name="description" content="This module contains the base Audio class and
the derived classes Song, Podcast and Audiobook." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>audiofiles.audiofiles</code></h1>
</header>
<section id="section-intro">
<p>This module contains the base Audio class and
the derived classes Song, Podcast and Audiobook.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains the base Audio class and
the derived classes Song, Podcast and Audiobook.
&#34;&#34;&#34;
import json
import typing
from datetime import datetime
from dataclasses import dataclass


class MetadataValueError(Exception):
    &#34;&#34;&#34; Custom exception to handle invalid metadata values &#34;&#34;&#34;
    pass


class MetadataGenerationError(Exception):
    &#34;&#34;&#34;Custom exception to handle failed metadata generation&#34;&#34;&#34;
    pass


@dataclass(repr=False)
class Audio:
    &#34;&#34;&#34;
    ************
    Description:
    ************
    *The base class for all other Audio type classes.*

    Accepts a metadata dictionary and stores it as an attribute.
    The post construction initialisation runtime checks the
    metadata for the other relevant attributes and sets them.

    The &#39;ID&#39; and &#39;uploadtime&#39; attributes are generated if not found in the metadata (considered
    as the first initialization of the object).
    The &#39;ID&#39; is generated by taking the absolute value of the hash generated for a string that
    contains the name, duration and uploadtime attributes.
    The &#39;uploadtime&#39; attribute is expected as an ISO8601 string and stored as a datetime object.

    *****************
    Class Attributes:
    *****************
    - ``ID``:       An int that uniquely identifies the audio file.
    - ``name``:     An str that describes the name of the audio file. Maximum length of 100.
    - ``duration``: A positive int that describes the length of the audio file. Must be positive.
    - ``uploadtime``:   A datetime object that is the time at which the audio file was uploaded.
    - ``metadata``: A dict that contains the audio file metadata.

    **************
    Class Methods:
    **************
    - ``validate_string``:  A method that checks if a given object is a string under 100 characters.
    - ``validate_duration``:    A method that checks if a given object is a positive integer.
    &#34;&#34;&#34;
    metadata: dict

    def __post_init__(self):
        &#34;&#34;&#34; Post Construction Initialisation Runtime &#34;&#34;&#34;

        # Collect &#39;name&#39; and &#39;duration&#39;
        try:
            self.name = self.metadata[&#39;name&#39;]
            self.duration = self.metadata[&#39;duration&#39;]

        except KeyError as e:
            raise MetadataValueError(f&#34;metadata value is missing for {e}&#34;)

        # Validate the &#39;name&#39;
        valid, error = self.validate_string(self.name)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;name&#39; - {error}&#34;)

        # Validate the &#39;duration&#39;
        valid, error = self.validate_duration(self.duration)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;duration&#39; - {error}&#34;)

        # Collect and validate &#39;uploadtime&#39;. Generate if not found.
        if &#39;uploadtime&#39; not in self.metadata:

            try:
                self.uploadtime = datetime.utcnow()
                self.metadata[&#39;uploadtime&#39;] = self.uploadtime.isoformat()

            except Exception as e:
                raise MetadataGenerationError(f&#34;metadata generation failed for &#39;uploadtime&#39;&#34;)
        else:

            try:
                uploadtime = self.metadata[&#39;uploadtime&#39;]
                self.uploadtime = datetime.fromisoformat(uploadtime)

            except ValueError:
                raise MetadataValueError(&#34;metadata value is invalid for &#39;uploadtime&#39; - not ISO8601&#34;)
            except TypeError:
                raise MetadataValueError(&#34;metadata value is invalid for &#39;uploadtime&#39; - not an str&#34;)

        # Collect and validate &#39;ID&#39;. Generate if not found.
        if &#39;_id&#39; in self.metadata:
            self.ID = self.metadata[&#39;_id&#39;]

            if not isinstance(self.ID, int):
                raise MetadataValueError(&#34;metadata value is invalid for &#39;_id&#39; - not an int&#34;)

        else:

            try:
                self.ID = abs(hash(f&#34;{self.name}-{self.duration}-{self.uploadtime.isoformat()}&#34;))
                self.metadata[&#39;_id&#39;] = self.ID

            except Exception as e:
                raise MetadataGenerationError(f&#34;metadata generation failed for &#39;id&#39;&#34;)

        # Collect and validate &#39;type&#39;. Generate if not found.
        if &#39;type&#39; in self.metadata:
            if not isinstance(self.metadata[&#39;type&#39;], str):
                raise MetadataValueError(&#34;metadata value is invalid for &#39;type&#39; - not an str&#34;)

            if self.metadata[&#39;type&#39;] not in [&#39;Song&#39;, &#39;Podcast&#39;, &#39;Audiobook&#39;, &#39;Audio&#39;]:
                raise MetadataValueError(&#34;metadata value is invalid for &#39;type&#39; - not supported&#34;)

        else:
            self.metadata[&#39;type&#39;] = &#34;Audio&#34;

    def __repr__(self):
        &#34;&#34;&#34; Representation of an Audio Object &#34;&#34;&#34;
        return f&#34;Audio Object &lt;ID={self.ID}, Name={self.name}&gt;&#34;

    def __str__(self):
        &#34;&#34;&#34; String Representation of an Audio Object &#34;&#34;&#34;
        return json.dumps(self.metadata)

    @classmethod
    def validate_duration(cls, duration: int) -&gt; typing.Tuple[bool, str]:
        &#34;&#34;&#34;
        A classmethod that determines if a given object is a string under 100 characters.
        Returns a validity bool and and an error str in a tuple.
        &#34;&#34;&#34;
        if not isinstance(duration, int):
            return False, &#34;not an int&#34;

        if duration &lt; 0:
            return False, &#34;not positive&#34;

        return True, &#34;null&#34;

    @classmethod
    def validate_string(cls, string: str) -&gt; typing.Tuple[bool, str]:
        &#34;&#34;&#34;
        A classmethod that determines if a given object is a positive integer.
        Returns a validity bool and and an error str in a tuple.
        &#34;&#34;&#34;
        if not isinstance(string, str):
            return False, &#34;not an str&#34;

        if len(string) &gt; 100:
            return False, &#34;str too long&#34;

        return True, &#34;null&#34;


@dataclass(repr=False)
class Song(Audio):
    &#34;&#34;&#34;
    ************
    Description:
    ************
    *The class for a Song object.*

    Accepts a metadata dictionary and stores it as an attribute.
    The post construction initialisation runtime checks the
    metadata for the other relevant attributes and sets them.

    The &#39;ID&#39; and &#39;uploadtime&#39; attributes are generated if not found in the metadata (considered
    as the first initialization of the object).
    The &#39;ID&#39; is generated by taking the absolute value of the hash generated for a string that
    contains the name, duration and uploadtime attributes.
    The &#39;uploadtime&#39; attribute is expected as an ISO8601 string and stored as a datetime object.

    *****************
    Class Attributes:
    *****************
    - ``ID``:       An int that uniquely identifies the song.
    - ``name``:     An str that describes the name of the song. Maximum length of 100.
    - ``duration``: A positive int that describes the length of the song. Must be positive.
    - ``uploadtime``:   A datetime object that is the time at which the song was uploaded.
    - ``metadata``: A dict that contains the song metadata.

    **************
    Class Methods:
    **************
    - ``validate_string``:  A method that checks if a given object is a string under 100 characters.
    - ``validate_duration``:    A method that checks if a given object is a positive integer.
    &#34;&#34;&#34;
    metadata: dict

    def __post_init__(self):
        &#34;&#34;&#34; Post Construction Initialisation Runtime &#34;&#34;&#34;
        self.metadata[&#39;type&#39;] = &#34;Song&#34;
        super(Song, self).__post_init__()

    def __repr__(self):
        &#34;&#34;&#34; Representation of an Song Object &#34;&#34;&#34;
        return f&#34;Song Object &lt;ID={self.ID}, Name={self.name}&gt;&#34;

    def __str__(self):
        &#34;&#34;&#34; String Representation of an Song Object &#34;&#34;&#34;
        return json.dumps(self.metadata)


@dataclass(repr=False)
class Podcast(Audio):
    &#34;&#34;&#34;
    ************
    Description:
    ************
    *The class for a Podcast object.*

    Accepts a metadata dictionary and stores it as an attribute.
    The post construction initialisation runtime checks the
    metadata for the other relevant attributes and sets them.

    The &#39;ID&#39; and &#39;uploadtime&#39; attributes are generated if not found in the metadata (considered
    as the first initialization of the object).
    The &#39;ID&#39; is generated by taking the absolute value of the hash generated for a string that
    contains the name, duration and uploadtime attributes.
    The &#39;uploadtime&#39; attribute is expected as an ISO8601 string and stored as a datetime object.
    The &#39;participants&#39; attribute is set to an empty list if none are passed.

    *****************
    Class Attributes:
    *****************
    - ``ID``:       An int that uniquely identifies the podcast.
    - ``name``:     An str that describes the name of the podcast. Maximum length of 100.
    - ``host``:     An str that describes the host of the podcast. Maximum length of 100.
    - ``participants``: A list of str that describes the participants of the podcast.
    - ``duration``: A positive int that describes the length of the podcast. Must be positive.
    - ``uploadtime``:   A datetime object that is the time at which the podcast was uploaded.
    - ``metadata``: A dict that contains the podcast metadata.

    **************
    Class Methods:
    **************
    - ``validate_string``:  A method that checks if a given object is a string under 100 characters.
    - ``validate_duration``:    A method that checks if a given object is a positive integer.
    - ``validate_participants``:    A method that checks if a given object is a list of valid str.
    &#34;&#34;&#34;
    metadata: dict

    def __post_init__(self):
        &#34;&#34;&#34; Post Construction Initialisation Runtime &#34;&#34;&#34;
        self.metadata[&#39;type&#39;] = &#34;Podcast&#34;
        super(Podcast, self).__post_init__()

        # Collect &#39;host&#39; and &#39;participants&#39;
        try:
            self.host = self.metadata[&#39;host&#39;]
            self.participants = self.metadata.get(&#39;participants&#39;)

        except KeyError as e:
            raise MetadataValueError(f&#34;metadata value is missing for {e}&#34;)

        # Validate the &#39;host&#39;
        valid, error = self.validate_string(self.host)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;host&#39; - {error}&#34;)

        if not self.participants:
            self.participants = []

        # Validate the &#39;participants&#39;
        valid, error = self.validate_participants(self.participants)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;participants&#39; - {error}&#34;)

    def __repr__(self):
        &#34;&#34;&#34; Representation of an Podcast Object &#34;&#34;&#34;
        return f&#34;Podcast Object &lt;ID={self.ID}, Name={self.name}&gt;&#34;

    def __str__(self):
        &#34;&#34;&#34; String Representation of an Podcast Object &#34;&#34;&#34;
        return json.dumps(self.metadata)

    @classmethod
    def validate_participants(cls, participants: list) -&gt; typing.Tuple[bool, str]:
        &#34;&#34;&#34;
        A classmethod that determines if a given object is a list of valid strings (under
        100 characters). Returns a validity bool and and an error str in a tuple.
        &#34;&#34;&#34;
        if not isinstance(participants, list):
            return False, &#34;not a list&#34;

        if len(participants) &gt; 10:
            return False, &#34;too many participants&#34;

        for count, participant in enumerate(participants, start=1):
            valid, error = cls.validate_string(participant)
            if not valid:
                return False, f&#34;participant {count} - {error}&#34;

        return True, &#34;null&#34;


@dataclass(repr=False)
class Audiobook(Audio):
    &#34;&#34;&#34;
    ************
    Description:
    ************
    *The class for a Audiobook object.*

    Accepts a metadata dictionary and stores it as an attribute.
    The post construction initialisation runtime checks the
    metadata for the other relevant attributes and sets them.

    The &#39;ID&#39; and &#39;uploadtime&#39; attributes are generated if not found in the metadata (considered
    as the first initialization of the object).
    The &#39;ID&#39; is generated by taking the absolute value of the hash generated for a string that
    contains the name, duration and uploadtime attributes.
    The &#39;uploadtime&#39; attribute is expected as an ISO8601 string and stored as a datetime object.

    *****************
    Class Attributes:
    *****************
    - ``ID``:       An int that uniquely identifies the song.
    - ``name``:     An str that describes the name of the song. Maximum length of 100.
    - ``author``:   An str that describes the author of the audiobook. Maximum length of 100.
    - ``narrator``: An str that describes the narrator of the audiobook. Maximum length of 100.
    - ``duration``: A positive int that describes the length of the song. Must be positive.
    - ``uploadtime``:   A datetime object that is the time at which the song was uploaded.
    - ``metadata``: A dict that contains the song metadata.

    **************
    Class Methods:
    **************
    - ``validate_string``:  A method that checks if a given object is a string under 100 characters.
    - ``validate_duration``:    A method that checks if a given object is a positive integer.
    &#34;&#34;&#34;
    metadata: dict

    def __post_init__(self):
        &#34;&#34;&#34; Post Construction Initialisation Runtime &#34;&#34;&#34;
        self.metadata[&#39;type&#39;] = &#34;Audiobook&#34;
        super(Audiobook, self).__post_init__()

        # Collect &#39;author&#39; and &#39;narrator&#39;
        try:
            self.author = self.metadata[&#39;author&#39;]
            self.narrator = self.metadata[&#39;narrator&#39;]

        except KeyError as e:
            raise MetadataValueError(f&#34;metadata value is missing for {e}&#34;)

        # Validate the &#39;author&#39;
        valid, error = self.validate_string(self.author)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;author&#39; - {error}&#34;)

        # Validate the &#39;narrator&#39;
        valid, error = self.validate_string(self.narrator)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;narrator&#39; - {error}&#34;)

    def __repr__(self):
        &#34;&#34;&#34; Representation of an Audiobook Object &#34;&#34;&#34;
        return f&#34;Audiobook Object &lt;ID={self.ID}, Name={self.name}&gt;&#34;

    def __str__(self):
        &#34;&#34;&#34; String Representation of an Audiobook Object &#34;&#34;&#34;
        return json.dumps(self.metadata)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="audiofiles.audiofiles.Audio"><code class="flex name class">
<span>class <span class="ident">Audio</span></span>
<span>(</span><span>metadata: dict)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Description:</p>
<hr>
<p><em>The base class for all other Audio type classes.</em></p>
<p>Accepts a metadata dictionary and stores it as an attribute.
The post construction initialisation runtime checks the
metadata for the other relevant attributes and sets them.</p>
<p>The 'ID' and 'uploadtime' attributes are generated if not found in the metadata (considered
as the first initialization of the object).
The 'ID' is generated by taking the absolute value of the hash generated for a string that
contains the name, duration and uploadtime attributes.
The 'uploadtime' attribute is expected as an ISO8601 string and stored as a datetime object.</p>
<hr>
<p>Class Attributes:</p>
<hr>
<ul>
<li><code>ID</code>:
An int that uniquely identifies the audio file.</li>
<li><code>name</code>:
An str that describes the name of the audio file. Maximum length of 100.</li>
<li><code>duration</code>: A positive int that describes the length of the audio file. Must be positive.</li>
<li><code>uploadtime</code>:
A datetime object that is the time at which the audio file was uploaded.</li>
<li><code>metadata</code>: A dict that contains the audio file metadata.</li>
</ul>
<hr>
<p>Class Methods:</p>
<hr>
<ul>
<li><code>validate_string</code>:
A method that checks if a given object is a string under 100 characters.</li>
<li><code>validate_duration</code>:
A method that checks if a given object is a positive integer.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Audio:
    &#34;&#34;&#34;
    ************
    Description:
    ************
    *The base class for all other Audio type classes.*

    Accepts a metadata dictionary and stores it as an attribute.
    The post construction initialisation runtime checks the
    metadata for the other relevant attributes and sets them.

    The &#39;ID&#39; and &#39;uploadtime&#39; attributes are generated if not found in the metadata (considered
    as the first initialization of the object).
    The &#39;ID&#39; is generated by taking the absolute value of the hash generated for a string that
    contains the name, duration and uploadtime attributes.
    The &#39;uploadtime&#39; attribute is expected as an ISO8601 string and stored as a datetime object.

    *****************
    Class Attributes:
    *****************
    - ``ID``:       An int that uniquely identifies the audio file.
    - ``name``:     An str that describes the name of the audio file. Maximum length of 100.
    - ``duration``: A positive int that describes the length of the audio file. Must be positive.
    - ``uploadtime``:   A datetime object that is the time at which the audio file was uploaded.
    - ``metadata``: A dict that contains the audio file metadata.

    **************
    Class Methods:
    **************
    - ``validate_string``:  A method that checks if a given object is a string under 100 characters.
    - ``validate_duration``:    A method that checks if a given object is a positive integer.
    &#34;&#34;&#34;
    metadata: dict

    def __post_init__(self):
        &#34;&#34;&#34; Post Construction Initialisation Runtime &#34;&#34;&#34;

        # Collect &#39;name&#39; and &#39;duration&#39;
        try:
            self.name = self.metadata[&#39;name&#39;]
            self.duration = self.metadata[&#39;duration&#39;]

        except KeyError as e:
            raise MetadataValueError(f&#34;metadata value is missing for {e}&#34;)

        # Validate the &#39;name&#39;
        valid, error = self.validate_string(self.name)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;name&#39; - {error}&#34;)

        # Validate the &#39;duration&#39;
        valid, error = self.validate_duration(self.duration)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;duration&#39; - {error}&#34;)

        # Collect and validate &#39;uploadtime&#39;. Generate if not found.
        if &#39;uploadtime&#39; not in self.metadata:

            try:
                self.uploadtime = datetime.utcnow()
                self.metadata[&#39;uploadtime&#39;] = self.uploadtime.isoformat()

            except Exception as e:
                raise MetadataGenerationError(f&#34;metadata generation failed for &#39;uploadtime&#39;&#34;)
        else:

            try:
                uploadtime = self.metadata[&#39;uploadtime&#39;]
                self.uploadtime = datetime.fromisoformat(uploadtime)

            except ValueError:
                raise MetadataValueError(&#34;metadata value is invalid for &#39;uploadtime&#39; - not ISO8601&#34;)
            except TypeError:
                raise MetadataValueError(&#34;metadata value is invalid for &#39;uploadtime&#39; - not an str&#34;)

        # Collect and validate &#39;ID&#39;. Generate if not found.
        if &#39;_id&#39; in self.metadata:
            self.ID = self.metadata[&#39;_id&#39;]

            if not isinstance(self.ID, int):
                raise MetadataValueError(&#34;metadata value is invalid for &#39;_id&#39; - not an int&#34;)

        else:

            try:
                self.ID = abs(hash(f&#34;{self.name}-{self.duration}-{self.uploadtime.isoformat()}&#34;))
                self.metadata[&#39;_id&#39;] = self.ID

            except Exception as e:
                raise MetadataGenerationError(f&#34;metadata generation failed for &#39;id&#39;&#34;)

        # Collect and validate &#39;type&#39;. Generate if not found.
        if &#39;type&#39; in self.metadata:
            if not isinstance(self.metadata[&#39;type&#39;], str):
                raise MetadataValueError(&#34;metadata value is invalid for &#39;type&#39; - not an str&#34;)

            if self.metadata[&#39;type&#39;] not in [&#39;Song&#39;, &#39;Podcast&#39;, &#39;Audiobook&#39;, &#39;Audio&#39;]:
                raise MetadataValueError(&#34;metadata value is invalid for &#39;type&#39; - not supported&#34;)

        else:
            self.metadata[&#39;type&#39;] = &#34;Audio&#34;

    def __repr__(self):
        &#34;&#34;&#34; Representation of an Audio Object &#34;&#34;&#34;
        return f&#34;Audio Object &lt;ID={self.ID}, Name={self.name}&gt;&#34;

    def __str__(self):
        &#34;&#34;&#34; String Representation of an Audio Object &#34;&#34;&#34;
        return json.dumps(self.metadata)

    @classmethod
    def validate_duration(cls, duration: int) -&gt; typing.Tuple[bool, str]:
        &#34;&#34;&#34;
        A classmethod that determines if a given object is a string under 100 characters.
        Returns a validity bool and and an error str in a tuple.
        &#34;&#34;&#34;
        if not isinstance(duration, int):
            return False, &#34;not an int&#34;

        if duration &lt; 0:
            return False, &#34;not positive&#34;

        return True, &#34;null&#34;

    @classmethod
    def validate_string(cls, string: str) -&gt; typing.Tuple[bool, str]:
        &#34;&#34;&#34;
        A classmethod that determines if a given object is a positive integer.
        Returns a validity bool and and an error str in a tuple.
        &#34;&#34;&#34;
        if not isinstance(string, str):
            return False, &#34;not an str&#34;

        if len(string) &gt; 100:
            return False, &#34;str too long&#34;

        return True, &#34;null&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="audiofiles.audiofiles.Audiobook" href="#audiofiles.audiofiles.Audiobook">Audiobook</a></li>
<li><a title="audiofiles.audiofiles.Podcast" href="#audiofiles.audiofiles.Podcast">Podcast</a></li>
<li><a title="audiofiles.audiofiles.Song" href="#audiofiles.audiofiles.Song">Song</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiofiles.audiofiles.Audio.metadata"><code class="name">var <span class="ident">metadata</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="audiofiles.audiofiles.Audio.validate_duration"><code class="name flex">
<span>def <span class="ident">validate_duration</span></span>(<span>duration: int) ‑> Tuple[bool, str]</span>
</code></dt>
<dd>
<div class="desc"><p>A classmethod that determines if a given object is a string under 100 characters.
Returns a validity bool and and an error str in a tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate_duration(cls, duration: int) -&gt; typing.Tuple[bool, str]:
    &#34;&#34;&#34;
    A classmethod that determines if a given object is a string under 100 characters.
    Returns a validity bool and and an error str in a tuple.
    &#34;&#34;&#34;
    if not isinstance(duration, int):
        return False, &#34;not an int&#34;

    if duration &lt; 0:
        return False, &#34;not positive&#34;

    return True, &#34;null&#34;</code></pre>
</details>
</dd>
<dt id="audiofiles.audiofiles.Audio.validate_string"><code class="name flex">
<span>def <span class="ident">validate_string</span></span>(<span>string: str) ‑> Tuple[bool, str]</span>
</code></dt>
<dd>
<div class="desc"><p>A classmethod that determines if a given object is a positive integer.
Returns a validity bool and and an error str in a tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate_string(cls, string: str) -&gt; typing.Tuple[bool, str]:
    &#34;&#34;&#34;
    A classmethod that determines if a given object is a positive integer.
    Returns a validity bool and and an error str in a tuple.
    &#34;&#34;&#34;
    if not isinstance(string, str):
        return False, &#34;not an str&#34;

    if len(string) &gt; 100:
        return False, &#34;str too long&#34;

    return True, &#34;null&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="audiofiles.audiofiles.Audiobook"><code class="flex name class">
<span>class <span class="ident">Audiobook</span></span>
<span>(</span><span>metadata: dict)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Description:</p>
<hr>
<p><em>The class for a Audiobook object.</em></p>
<p>Accepts a metadata dictionary and stores it as an attribute.
The post construction initialisation runtime checks the
metadata for the other relevant attributes and sets them.</p>
<p>The 'ID' and 'uploadtime' attributes are generated if not found in the metadata (considered
as the first initialization of the object).
The 'ID' is generated by taking the absolute value of the hash generated for a string that
contains the name, duration and uploadtime attributes.
The 'uploadtime' attribute is expected as an ISO8601 string and stored as a datetime object.</p>
<hr>
<p>Class Attributes:</p>
<hr>
<ul>
<li><code>ID</code>:
An int that uniquely identifies the song.</li>
<li><code>name</code>:
An str that describes the name of the song. Maximum length of 100.</li>
<li><code>author</code>:
An str that describes the author of the audiobook. Maximum length of 100.</li>
<li><code>narrator</code>: An str that describes the narrator of the audiobook. Maximum length of 100.</li>
<li><code>duration</code>: A positive int that describes the length of the song. Must be positive.</li>
<li><code>uploadtime</code>:
A datetime object that is the time at which the song was uploaded.</li>
<li><code>metadata</code>: A dict that contains the song metadata.</li>
</ul>
<hr>
<p>Class Methods:</p>
<hr>
<ul>
<li><code>validate_string</code>:
A method that checks if a given object is a string under 100 characters.</li>
<li><code>validate_duration</code>:
A method that checks if a given object is a positive integer.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Audiobook(Audio):
    &#34;&#34;&#34;
    ************
    Description:
    ************
    *The class for a Audiobook object.*

    Accepts a metadata dictionary and stores it as an attribute.
    The post construction initialisation runtime checks the
    metadata for the other relevant attributes and sets them.

    The &#39;ID&#39; and &#39;uploadtime&#39; attributes are generated if not found in the metadata (considered
    as the first initialization of the object).
    The &#39;ID&#39; is generated by taking the absolute value of the hash generated for a string that
    contains the name, duration and uploadtime attributes.
    The &#39;uploadtime&#39; attribute is expected as an ISO8601 string and stored as a datetime object.

    *****************
    Class Attributes:
    *****************
    - ``ID``:       An int that uniquely identifies the song.
    - ``name``:     An str that describes the name of the song. Maximum length of 100.
    - ``author``:   An str that describes the author of the audiobook. Maximum length of 100.
    - ``narrator``: An str that describes the narrator of the audiobook. Maximum length of 100.
    - ``duration``: A positive int that describes the length of the song. Must be positive.
    - ``uploadtime``:   A datetime object that is the time at which the song was uploaded.
    - ``metadata``: A dict that contains the song metadata.

    **************
    Class Methods:
    **************
    - ``validate_string``:  A method that checks if a given object is a string under 100 characters.
    - ``validate_duration``:    A method that checks if a given object is a positive integer.
    &#34;&#34;&#34;
    metadata: dict

    def __post_init__(self):
        &#34;&#34;&#34; Post Construction Initialisation Runtime &#34;&#34;&#34;
        self.metadata[&#39;type&#39;] = &#34;Audiobook&#34;
        super(Audiobook, self).__post_init__()

        # Collect &#39;author&#39; and &#39;narrator&#39;
        try:
            self.author = self.metadata[&#39;author&#39;]
            self.narrator = self.metadata[&#39;narrator&#39;]

        except KeyError as e:
            raise MetadataValueError(f&#34;metadata value is missing for {e}&#34;)

        # Validate the &#39;author&#39;
        valid, error = self.validate_string(self.author)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;author&#39; - {error}&#34;)

        # Validate the &#39;narrator&#39;
        valid, error = self.validate_string(self.narrator)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;narrator&#39; - {error}&#34;)

    def __repr__(self):
        &#34;&#34;&#34; Representation of an Audiobook Object &#34;&#34;&#34;
        return f&#34;Audiobook Object &lt;ID={self.ID}, Name={self.name}&gt;&#34;

    def __str__(self):
        &#34;&#34;&#34; String Representation of an Audiobook Object &#34;&#34;&#34;
        return json.dumps(self.metadata)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="audiofiles.audiofiles.Audio" href="#audiofiles.audiofiles.Audio">Audio</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiofiles.audiofiles.Audiobook.metadata"><code class="name">var <span class="ident">metadata</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="audiofiles.audiofiles.Audio" href="#audiofiles.audiofiles.Audio">Audio</a></b></code>:
<ul class="hlist">
<li><code><a title="audiofiles.audiofiles.Audio.validate_duration" href="#audiofiles.audiofiles.Audio.validate_duration">validate_duration</a></code></li>
<li><code><a title="audiofiles.audiofiles.Audio.validate_string" href="#audiofiles.audiofiles.Audio.validate_string">validate_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="audiofiles.audiofiles.MetadataGenerationError"><code class="flex name class">
<span>class <span class="ident">MetadataGenerationError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom exception to handle failed metadata generation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetadataGenerationError(Exception):
    &#34;&#34;&#34;Custom exception to handle failed metadata generation&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="audiofiles.audiofiles.MetadataValueError"><code class="flex name class">
<span>class <span class="ident">MetadataValueError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom exception to handle invalid metadata values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetadataValueError(Exception):
    &#34;&#34;&#34; Custom exception to handle invalid metadata values &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="audiofiles.audiofiles.Podcast"><code class="flex name class">
<span>class <span class="ident">Podcast</span></span>
<span>(</span><span>metadata: dict)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Description:</p>
<hr>
<p><em>The class for a Podcast object.</em></p>
<p>Accepts a metadata dictionary and stores it as an attribute.
The post construction initialisation runtime checks the
metadata for the other relevant attributes and sets them.</p>
<p>The 'ID' and 'uploadtime' attributes are generated if not found in the metadata (considered
as the first initialization of the object).
The 'ID' is generated by taking the absolute value of the hash generated for a string that
contains the name, duration and uploadtime attributes.
The 'uploadtime' attribute is expected as an ISO8601 string and stored as a datetime object.
The 'participants' attribute is set to an empty list if none are passed.</p>
<hr>
<p>Class Attributes:</p>
<hr>
<ul>
<li><code>ID</code>:
An int that uniquely identifies the podcast.</li>
<li><code>name</code>:
An str that describes the name of the podcast. Maximum length of 100.</li>
<li><code>host</code>:
An str that describes the host of the podcast. Maximum length of 100.</li>
<li><code>participants</code>: A list of str that describes the participants of the podcast.</li>
<li><code>duration</code>: A positive int that describes the length of the podcast. Must be positive.</li>
<li><code>uploadtime</code>:
A datetime object that is the time at which the podcast was uploaded.</li>
<li><code>metadata</code>: A dict that contains the podcast metadata.</li>
</ul>
<hr>
<p>Class Methods:</p>
<hr>
<ul>
<li><code>validate_string</code>:
A method that checks if a given object is a string under 100 characters.</li>
<li><code>validate_duration</code>:
A method that checks if a given object is a positive integer.</li>
<li><code>validate_participants</code>:
A method that checks if a given object is a list of valid str.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Podcast(Audio):
    &#34;&#34;&#34;
    ************
    Description:
    ************
    *The class for a Podcast object.*

    Accepts a metadata dictionary and stores it as an attribute.
    The post construction initialisation runtime checks the
    metadata for the other relevant attributes and sets them.

    The &#39;ID&#39; and &#39;uploadtime&#39; attributes are generated if not found in the metadata (considered
    as the first initialization of the object).
    The &#39;ID&#39; is generated by taking the absolute value of the hash generated for a string that
    contains the name, duration and uploadtime attributes.
    The &#39;uploadtime&#39; attribute is expected as an ISO8601 string and stored as a datetime object.
    The &#39;participants&#39; attribute is set to an empty list if none are passed.

    *****************
    Class Attributes:
    *****************
    - ``ID``:       An int that uniquely identifies the podcast.
    - ``name``:     An str that describes the name of the podcast. Maximum length of 100.
    - ``host``:     An str that describes the host of the podcast. Maximum length of 100.
    - ``participants``: A list of str that describes the participants of the podcast.
    - ``duration``: A positive int that describes the length of the podcast. Must be positive.
    - ``uploadtime``:   A datetime object that is the time at which the podcast was uploaded.
    - ``metadata``: A dict that contains the podcast metadata.

    **************
    Class Methods:
    **************
    - ``validate_string``:  A method that checks if a given object is a string under 100 characters.
    - ``validate_duration``:    A method that checks if a given object is a positive integer.
    - ``validate_participants``:    A method that checks if a given object is a list of valid str.
    &#34;&#34;&#34;
    metadata: dict

    def __post_init__(self):
        &#34;&#34;&#34; Post Construction Initialisation Runtime &#34;&#34;&#34;
        self.metadata[&#39;type&#39;] = &#34;Podcast&#34;
        super(Podcast, self).__post_init__()

        # Collect &#39;host&#39; and &#39;participants&#39;
        try:
            self.host = self.metadata[&#39;host&#39;]
            self.participants = self.metadata.get(&#39;participants&#39;)

        except KeyError as e:
            raise MetadataValueError(f&#34;metadata value is missing for {e}&#34;)

        # Validate the &#39;host&#39;
        valid, error = self.validate_string(self.host)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;host&#39; - {error}&#34;)

        if not self.participants:
            self.participants = []

        # Validate the &#39;participants&#39;
        valid, error = self.validate_participants(self.participants)
        if not valid:
            raise MetadataValueError(f&#34;metadata value is invalid for &#39;participants&#39; - {error}&#34;)

    def __repr__(self):
        &#34;&#34;&#34; Representation of an Podcast Object &#34;&#34;&#34;
        return f&#34;Podcast Object &lt;ID={self.ID}, Name={self.name}&gt;&#34;

    def __str__(self):
        &#34;&#34;&#34; String Representation of an Podcast Object &#34;&#34;&#34;
        return json.dumps(self.metadata)

    @classmethod
    def validate_participants(cls, participants: list) -&gt; typing.Tuple[bool, str]:
        &#34;&#34;&#34;
        A classmethod that determines if a given object is a list of valid strings (under
        100 characters). Returns a validity bool and and an error str in a tuple.
        &#34;&#34;&#34;
        if not isinstance(participants, list):
            return False, &#34;not a list&#34;

        if len(participants) &gt; 10:
            return False, &#34;too many participants&#34;

        for count, participant in enumerate(participants, start=1):
            valid, error = cls.validate_string(participant)
            if not valid:
                return False, f&#34;participant {count} - {error}&#34;

        return True, &#34;null&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="audiofiles.audiofiles.Audio" href="#audiofiles.audiofiles.Audio">Audio</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiofiles.audiofiles.Podcast.metadata"><code class="name">var <span class="ident">metadata</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="audiofiles.audiofiles.Podcast.validate_participants"><code class="name flex">
<span>def <span class="ident">validate_participants</span></span>(<span>participants: list) ‑> Tuple[bool, str]</span>
</code></dt>
<dd>
<div class="desc"><p>A classmethod that determines if a given object is a list of valid strings (under
100 characters). Returns a validity bool and and an error str in a tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate_participants(cls, participants: list) -&gt; typing.Tuple[bool, str]:
    &#34;&#34;&#34;
    A classmethod that determines if a given object is a list of valid strings (under
    100 characters). Returns a validity bool and and an error str in a tuple.
    &#34;&#34;&#34;
    if not isinstance(participants, list):
        return False, &#34;not a list&#34;

    if len(participants) &gt; 10:
        return False, &#34;too many participants&#34;

    for count, participant in enumerate(participants, start=1):
        valid, error = cls.validate_string(participant)
        if not valid:
            return False, f&#34;participant {count} - {error}&#34;

    return True, &#34;null&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="audiofiles.audiofiles.Audio" href="#audiofiles.audiofiles.Audio">Audio</a></b></code>:
<ul class="hlist">
<li><code><a title="audiofiles.audiofiles.Audio.validate_duration" href="#audiofiles.audiofiles.Audio.validate_duration">validate_duration</a></code></li>
<li><code><a title="audiofiles.audiofiles.Audio.validate_string" href="#audiofiles.audiofiles.Audio.validate_string">validate_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="audiofiles.audiofiles.Song"><code class="flex name class">
<span>class <span class="ident">Song</span></span>
<span>(</span><span>metadata: dict)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<p>Description:</p>
<hr>
<p><em>The class for a Song object.</em></p>
<p>Accepts a metadata dictionary and stores it as an attribute.
The post construction initialisation runtime checks the
metadata for the other relevant attributes and sets them.</p>
<p>The 'ID' and 'uploadtime' attributes are generated if not found in the metadata (considered
as the first initialization of the object).
The 'ID' is generated by taking the absolute value of the hash generated for a string that
contains the name, duration and uploadtime attributes.
The 'uploadtime' attribute is expected as an ISO8601 string and stored as a datetime object.</p>
<hr>
<p>Class Attributes:</p>
<hr>
<ul>
<li><code>ID</code>:
An int that uniquely identifies the song.</li>
<li><code>name</code>:
An str that describes the name of the song. Maximum length of 100.</li>
<li><code>duration</code>: A positive int that describes the length of the song. Must be positive.</li>
<li><code>uploadtime</code>:
A datetime object that is the time at which the song was uploaded.</li>
<li><code>metadata</code>: A dict that contains the song metadata.</li>
</ul>
<hr>
<p>Class Methods:</p>
<hr>
<ul>
<li><code>validate_string</code>:
A method that checks if a given object is a string under 100 characters.</li>
<li><code>validate_duration</code>:
A method that checks if a given object is a positive integer.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Song(Audio):
    &#34;&#34;&#34;
    ************
    Description:
    ************
    *The class for a Song object.*

    Accepts a metadata dictionary and stores it as an attribute.
    The post construction initialisation runtime checks the
    metadata for the other relevant attributes and sets them.

    The &#39;ID&#39; and &#39;uploadtime&#39; attributes are generated if not found in the metadata (considered
    as the first initialization of the object).
    The &#39;ID&#39; is generated by taking the absolute value of the hash generated for a string that
    contains the name, duration and uploadtime attributes.
    The &#39;uploadtime&#39; attribute is expected as an ISO8601 string and stored as a datetime object.

    *****************
    Class Attributes:
    *****************
    - ``ID``:       An int that uniquely identifies the song.
    - ``name``:     An str that describes the name of the song. Maximum length of 100.
    - ``duration``: A positive int that describes the length of the song. Must be positive.
    - ``uploadtime``:   A datetime object that is the time at which the song was uploaded.
    - ``metadata``: A dict that contains the song metadata.

    **************
    Class Methods:
    **************
    - ``validate_string``:  A method that checks if a given object is a string under 100 characters.
    - ``validate_duration``:    A method that checks if a given object is a positive integer.
    &#34;&#34;&#34;
    metadata: dict

    def __post_init__(self):
        &#34;&#34;&#34; Post Construction Initialisation Runtime &#34;&#34;&#34;
        self.metadata[&#39;type&#39;] = &#34;Song&#34;
        super(Song, self).__post_init__()

    def __repr__(self):
        &#34;&#34;&#34; Representation of an Song Object &#34;&#34;&#34;
        return f&#34;Song Object &lt;ID={self.ID}, Name={self.name}&gt;&#34;

    def __str__(self):
        &#34;&#34;&#34; String Representation of an Song Object &#34;&#34;&#34;
        return json.dumps(self.metadata)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="audiofiles.audiofiles.Audio" href="#audiofiles.audiofiles.Audio">Audio</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiofiles.audiofiles.Song.metadata"><code class="name">var <span class="ident">metadata</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="audiofiles.audiofiles.Audio" href="#audiofiles.audiofiles.Audio">Audio</a></b></code>:
<ul class="hlist">
<li><code><a title="audiofiles.audiofiles.Audio.validate_duration" href="#audiofiles.audiofiles.Audio.validate_duration">validate_duration</a></code></li>
<li><code><a title="audiofiles.audiofiles.Audio.validate_string" href="#audiofiles.audiofiles.Audio.validate_string">validate_string</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="audiofiles" href="index.html">audiofiles</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="audiofiles.audiofiles.Audio" href="#audiofiles.audiofiles.Audio">Audio</a></code></h4>
<ul class="">
<li><code><a title="audiofiles.audiofiles.Audio.metadata" href="#audiofiles.audiofiles.Audio.metadata">metadata</a></code></li>
<li><code><a title="audiofiles.audiofiles.Audio.validate_duration" href="#audiofiles.audiofiles.Audio.validate_duration">validate_duration</a></code></li>
<li><code><a title="audiofiles.audiofiles.Audio.validate_string" href="#audiofiles.audiofiles.Audio.validate_string">validate_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="audiofiles.audiofiles.Audiobook" href="#audiofiles.audiofiles.Audiobook">Audiobook</a></code></h4>
<ul class="">
<li><code><a title="audiofiles.audiofiles.Audiobook.metadata" href="#audiofiles.audiofiles.Audiobook.metadata">metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="audiofiles.audiofiles.MetadataGenerationError" href="#audiofiles.audiofiles.MetadataGenerationError">MetadataGenerationError</a></code></h4>
</li>
<li>
<h4><code><a title="audiofiles.audiofiles.MetadataValueError" href="#audiofiles.audiofiles.MetadataValueError">MetadataValueError</a></code></h4>
</li>
<li>
<h4><code><a title="audiofiles.audiofiles.Podcast" href="#audiofiles.audiofiles.Podcast">Podcast</a></code></h4>
<ul class="">
<li><code><a title="audiofiles.audiofiles.Podcast.metadata" href="#audiofiles.audiofiles.Podcast.metadata">metadata</a></code></li>
<li><code><a title="audiofiles.audiofiles.Podcast.validate_participants" href="#audiofiles.audiofiles.Podcast.validate_participants">validate_participants</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="audiofiles.audiofiles.Song" href="#audiofiles.audiofiles.Song">Song</a></code></h4>
<ul class="">
<li><code><a title="audiofiles.audiofiles.Song.metadata" href="#audiofiles.audiofiles.Song.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>